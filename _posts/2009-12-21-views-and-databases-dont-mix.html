--- 
layout: post
title: "Views and Databases Don\xE2\x80\x99t Mix"
tags: 
- ASP.NET MVC
- NHibernate
- ViewModel
status: publish
type: post
published: true
meta: 
  _edit_last: "1"
---
<h2>The Problem</h2>  <p>In my MVC applications, I sometimes bind my views directly to NHibernate entities. a lot. like always. I also do session-per-request. </p>  <p>I don’t remember what prompted this thought – probably Twitter – but it seemed questionable to access the database from the view by loading a lazy collection. I knew you shouldn’t put database access <strong><em>code</em></strong> in the view, but this would just be a property, nothing complex at all. <a href="http://ayende.com/Blog/" target="_blank">Ayende</a> set me straight. </p>  <blockquote>   <p>You should avoid it. It is dangerous to do loading in the     <br />view, it is subject to too many changes.</p> </blockquote>  <p>How do we prevent it? Of course, the simple answer is “just don’t do it.” Anything more quickly falls in the category of protecting you from yourself, of which I’m usually not a fan. Still, this is easy to overlook. The <a href="http://haacked.com/archive/2005/08/03/DoesMortKnowWeAreTalkingSmackAboutHimBehindHisBack.aspx" target="_blank">Morts</a> of the world – and me - will fall in to this trap easily. </p>  <h2>ViewModel Solution</h2>  <p>What if we had some sort of model, but instead of being generic for the entire application, it only dealt with the concerns of a specific view. Oh, and what if we called it something weird like viewmodel. </p>  <p>This is the best way to avoid problems. Instead of binding directly to an entity, each view should have a corresponding viewmodel class, that contains all of the data being pushed down to the view as well as all the data collected by the view from the user. It’s a POCO specific to the view, with no association to the NHibernate session, so it can’t accidentally load up some data. </p>  <p>You can easily test your viewmodels. Since they also make your views pretty darn stupid, you can maybe skip some of that time-consuming UI testing. Well, skip it safely this time. ViewModels also work well for all that validation attribute markup. Just sayin’.</p>  <p>This isn’t the point of my post today, and what I’ve described isn’t the traditional Model-View-ViewModel. It’s some weird hybrid of separated presentation patterns. You can read more about view models <a href="http://jeffhandley.com/archive/2008/10/21/viewmodel-pattern.aspx" target="_blank">here</a> and <a href="http://jeffhandley.com/archive/2008/10/27/helloworld.viewmodel.aspx" target="_blank">here</a> and on <a href="http://jfromaniello.blogspot.com/2009/08/nhibernate-and-wpf-viewmodels-and-views.html" target="_blank">Jose’s Chinook Media Manager application series</a>. </p>  <h2>Exploding View Solution</h2>  <p><a href="http://jasondentler.com/blog/wp-content/uploads/2009/12/image.png"><img style="border-bottom: 0px; border-left: 0px; margin: 4px 20px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" align="left" src="http://jasondentler.com/blog/wp-content/uploads/2009/12/image_thumb.png" width="125" height="225" /></a> While I can’t say it’s worse than something silently breaking, I don’t like the idea of something bad silently working. Fragile code only works until the worst possible moment.</p>  <p>So, without going for a full ViewModel implementation, I thought it would be a good thing (or at least slightly better) to make NHibernate throw an exception when we hit the DB in the view so we have to fix it now while we’re debugging instead of later. I initially had thoughts about interceptors or connection providers and all sorts of craziness. Ayende’s answer is simply to close the session at the controller boundary. </p>  <p>How do we implement this? We close the session between the controller action and the view. So, instead of session per (the entire) request, we trim the scope at the end just a bit. </p>  <p>Let’s take a high-level look at a chunk of the <a href="http://www.asp.net/mvc/" target="_blank">ASP.NET MVC</a> lifecycle:</p>  <ol>   <li>A controller action is chosen based on the request and action filters like HttpGet or HttpPost.</li>    <li>The action (the actual controller method) executes, returning an action result – a ViewResult, RedirectToActionResult, ContentResult, or some other built-in or custom action result.</li>    <li>The action result executes. In the case of a ViewResult, the view is rendered down to actual HTML and written out to the response stream. </li> </ol>  <p>We need to close down the session between #2 and #3. Lucky for us, every controller has an overloadable / overridable method called OnResultExecuting. This method gets called just before the action result is executed. We can simply override this method in our application’s base controller class. You have one of those, right? They’re handy for all sorts of stuff.</p>  <p>Just close down any session we may have open inside OnResultExecuting. Considering the references, this takes a little bit of plumbing, but I’ll leave that up to you since it’s dependent on your method of opening and tracking NHibernate sessions through the request. </p>  <p></p>  <p></p>  <h4>One last thing</h4>  <p>Maybe in a later version of <a href="http://nhprof.com" target="_blank">NH Profiler</a>, the problem I described today will trigger an alert. Maybe not. </p>  <p>If you’re using <a href="http://nhforge.org" target="_blank">NHibernate</a> without NH Profiler, you’re either writing substandard code or wasting time – probably both. If you don’t believe me, download a trial and see what it tells you about your last NHibernate app.</p>
