--- 
layout: post
title: "NHibernate Read Models: An Elephant in the Elevator"
tags: []

status: publish
type: post
published: true
meta: {}

---
<p>Our company website is a mostly well-architected <a href="http://nhforge.org/">NHibernate</a> web application. There’s a few data access related performance problems, like ghost writes. I’m confident these issues account for most of the slowness, but the site is still pretty snappy considering we just set debug=”false” and hit publish. </p>  <p>Entities were modeled after the business and mapped on to a proper 3rd normal form database with no aggregate boundaries. The object graph for a given query can easily be 5 or 6 layers deep. Translated in to SQL, this means an explosion of joins. The vast majority of the database is populated nightly from SSIS packages and otherwise completely read-only.</p>  <p>I’ve seen this movie before. Hell, I’ve directed, starred in, and won an Oscar for this movie. Haven’t we all? The database is modeled after the business, and then pinched and pulled and squished to service a query-heavy application or query-only web site. By the time you’ve finally pushed that NHibernate elephant in to the elevator, you and your app are bruised and brittle.</p>  <p>We did all that work to get to a point where we’re murdering our SQL database with the same joins over and over. It would require MUCH less processing power to pre-calculate each view model and make it easy to fetch quickly.</p>  <p>This past week, I attended the <a href="http://www.headspring.com/services/developer-training/nservicebus-boot-camp" target="_blank">NServiceBus Boot Camp</a>. What an amazing Christmas gift! I can’t recommend it enough. I wish we’d had time to dig in to CQRS read models more, but here’s a few points on the topic:</p>  <ol>   <li>The read model SQL database lives on the web server. Think of it as a cache, just more explicit. </li>    <li>Domain processing happens elsewhere and publishes events. </li>    <li>Handlers on the web server handle those events and update the read model accordingly. NHibernate feels heavy here. Consider a Micro-ORM. </li>    <li>Reads go directly to the local database. Query with something really light, then bind the result to the page. </li> </ol>  <p>Though I haven’t tried it, I suspect <a href="http://ayende.com/blog/136196/when-should-you-use-ravendb" target="_blank">RavenDB would be a good alternative to SQL on the web server</a>.</p>
